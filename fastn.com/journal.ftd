-- import: fifthtry.github.io/Jupiter-theme as ft
-- import: config

-- ft.doc-page:
toc: $config.dev-toc
id: page


-- ft.h0: FTD Journal

-- ft.h1: Object Gets $ref syntax & message-host only accepts objects

-- ft.h1: "Main" Variables

18th Jan 2022

Some variables, like `fpm.document-title`, could be set by more than one ftd
documents, each document is telling us what is the document-title for that
document by setting `fpm.document-title`.

But we allow authors to import any document from any other document, barring
cycles, so these variables can get clobbered. Say if there is `a.ftd` and `b.ftd`
and former wants document title to `A` and later to `B`, they can do both:
`-- fpm.document-title: A` and so on. But what if `a.ftd` looks like this:

-- ft.code:
lang: ftd

\-- import: fpm

\-- fpm.document-title: A

\-- import: b

-- ft.markdown:

`b.ftd` would be imported after `a.ftd` has updated `fpm.document-title`, and
it will overwrite `fpm.document-title`. We can argue this is fine at some level
and user is aware of things.

Further there is another concern, what if `fpm.document-title` was optional, and
the idea was if this is not set, we pick the title from first heading of the
document. And say this worked out fine, so `a.ftd` will not want to
`fpm.document-title`, but say it does not work for `b.ftd` so it wants to
explicitly set it. But then `a.ftd` imports `b.ftd`. We can not solve by import
order etc.

Proposal:

-- ft.code: `fpm.ftd` file
lang: ftd

\-- optional string document-title:
$main$: true

-- ft.markdown:

If any variable or list is defined as `$main$`, then only the changes done by
the "main document" would be kept. FTD interpreter knows whats the main document
that is being interpreted, and it knows when it is interpreting one of its
dependencies (via import).

We can further allow `$main$` during variable change also to allow non main
documents to update variable still, eg a `config.ftd` or some file which is
only for setting project variables.

-- ft.code: `config.ftd`
lang: ftd

\-- import: fpm
\-- fpm.site-title: AmitU's Blog
$main$: true

-- ft.markdown:

Further when any "main" document is importing some document, it can declare that
that document be also considered main:

-- ft.code: `a.ftd`
lang: ftd

\-- import: config
$main$: true
\-- import: b

-- ft.markdown:

Here we have imported `config` as "main", but not `b`.

This would be applicable for both variable overwrite, and for adding a an element
to a list, either can use "$main$".

-- ft.h2: In Other Words

1. some variables can be declared as $main$.
1. a `$main$` variable can only be modified by
   1. document that is considered `$main$`, 3. and 4. decide when a document is
      considered `$main$`
   1. or by forcing update by include `$main$` while updating the variable
1. the document that started the interpreter is the initial `$main$` document
1. when a `$main$` document is importing some document it can declare those
   document as `$main$` as well

-- ft.h2: Edge Case

Consider if `b.ftd`:

-- ft.code:
lang: ftd

\-- import: fpm
\-- fpm.document-title: B

\-- ftd.text show-title: $fpm.title


-- ft.markdown:

And say `a.ftd` was:

-- ft.code:
lang: ftd

\-- import: fpm
\-- fpm.document-title: A
\-- import: b
\-- b.show-title:

-- ft.markdown:

The `show-title` will show `A` and not `B` even though if you look at source
of `show-title` in `b.ftd` it appears it is modifying a variable and using it
right away.

This is not particularly confusing because a variable could have been updated
multiple times, even within the same file:

-- ft.code:
lang: ftd

\-- import: fpm
\-- fpm.document-title: B

\-- ftd.text show-title: $fpm.title

\-- fpm.document-title: New B

-- ft.markdown:

In this case, the immediate value of `fpm.document-title` is not used by
`show-title`, but the "eventual value".


-- ft.h1: `$processor$`, `async`, `Library::get()` and `Document::set_*()`

16th Jan 2022

One of the things that has emerged since yesterdays brain storm with Arpita is
we need first class support for updating FTD variables from "host languages".

You can say we have already two host languages, Rust and JavaScript. Once a
variable has been defined in FTD it can be updated by by Rust code on backend
using `ftd::Document::set_bool()` etc family of functions. Similarly the variable
can be updated by `window.ftd.set_bool()` etc family of functions.

So we have an emerging pattern, we define some variables in FTD with some initial
values, and they can be made dynamic by host. If we make this a first class thing,
currently we only support changes to basic types like boolean and string, if we
support complete access to FTD internals from host, and reliably update the FTD
"view" based on FTD data it would be cool.

-- ft.h2: `Library::get()` Simplification

Currently we have a technique where we create "virtual" FTD documents, e.g. there
is a module `fpm` for our FPM static site generator. This module is dynamically
constructed with actual values set for all these variables. This is done so we
can pass a bunch of data that we have in Rust to FTD files. So we do something
like [this](https://github.com/FifthTry/fpm/blob/8a0ce82571921e275292532b211a2dcaad618131/src/library/mod.rs#L136-L336):

-- ft.code: dynamically generating `last_modified_on`
lang: rs

format!(
    indoc::indoc! {"
        -- record ui-data:
        string last-modified-on:

        -- ui-data ui:
        last-modified-on: {last_modified_on}
     "},
    last_modified_on = fpm::i18n::translation::search(
        &lang,
        &primary_lang,
        "last-modified-on",
        &current_document_last_modified_on
    ),
)

-- ft.markdown:

We are setting `last_modified_on` based on string substitution in Rust using
`format!()` statement.

If we have first class support for setting any variable from Rust, we can keep
`fpm.ftd` file static, with no data in it, and load it to create FTD variables,
and then update each of the variables defined by `fpm.ftd` file.

This means our `ftd::Library::get()` methods can be simplified. It currently
perform two tasks:

1. Given an ID, it transforms the ID, e.g. it looks up the ID in dependency list,
   applies complex module resolution logic and reads the final file from disc.
2. It generates dynamic ftd files like I shown above.

The transformation etc can be done in a `sync` way. Reading a file itself can
be argued to be `async`, but for many cases it can be considered sync, say if
you have an in-memory database of ftd files.

Point is, if we recommended use case 2, it would necessarily mean `ftd::Library::get()`
be strongly `async`, allow arbitrary complex data lookups, HTTP API calls, database
calls and so on. Where as if `::get()` is only for loading FTD files, it's relatively
simpler. In many many use cases, say for serving blog or static content, content
is small and can be read on application start, with some watcher to keep updating
in memory cache on file system changes. In other cases, say FTD working as
primary front-end for application, the number of FTD files would be even smaller
in general. So it is conceivable to keep entire set of FTD files in memory.

This will still leave out fetching FTD files from say internet. If we want to
support that, and there may be some security issues there, but maybe they are
solvable somehow and in general we should allow fetching from internet etc.

So while we can not fully make `ftd::Library::get()` `sync`, at least we can
limit it's complexity, and not have two ways to set dynamic data.

-- ft.h2: Reviewing `$processor$`

So if we have first class support for update FTD data from host languages, then
do we still need `$processor$`?

Our `ftd::Library` Rust `trait` exposes another method `::process()` whenever
FTD interpreter encounters a `$processor$` directive. `process()` computes the
data, and passes it to interpreter, and then interpreter continues interpreting
the rest of the document.

Technically we can make this also two pass, let the interpreter interpret the
entire document in peace (only interrupted by `::get()` calls, to be executed
every time interpreter comes across an `-- import:` directive).

We are basically seeing if we can make the whole interpret pass "pure
computation". Now we proved `get()` can't be pure yet and we probably will accept
that design choice. But what about `$processor$`? Can we remove it?

One key difference between `fpm` scenario I described above vs `$processor$` is
`fpm` was "well known". `fpm` module is well documented (or is going to be), and
so Rust code knows what all dynamic variables are there, and Rust can update them.

But in case of `$processor$`, it can be applied on any user variable defined in
arbitrary FTD file. Interpreter can give each of `$processor$` variables a
default value, go through the document once, and afterwards let Rust update it
How would Rust know what all variables to update?

-- ft.code: `$processor$` to update variable
lang: ftd

\-- string foo:
$processor$: get-some-data-from-internet

-- ft.markdown:

Here we have a processor `get-some-data-from-internet`, which returns a `string`,
and the string is bound to the name `foo` in FTD.

Currently when interpreter encounters `$processor$` directive, it immediately
calls the `get-some-data-from-internet` (via `Library::process()`), and
initializes `foo`.

If we want to do it after the fact, we would have to discover what all variables
have processor applied.

We have another use case of processor planned:

-- ft.code: `$processor$` to component
lang: ftd

\-- ftd.text:
$processor$: get-some-data-from-internet

-- ft.markdown:

In this case we are not keeping the output of `get-some-data-from-internet` in
any FTD variable, but instead directly passing the value to the component.

Currently there is no plan to allow host to directly modify the FTD generated
DOM, we want to do it via data updates, host only knows about data, updates the
data, and UI updates itself.

On the whole it feels to me that creating new API to get variables that have
`$processor$` or worse allowing host to directly update DOM are not great ideas.

So our interpreter can not really be pure data operation, and it seems the best
design is to allow for first class `async` support and continue on current path.



-- ft.h1: Object Implementation Details

15th Jan 2022

So Arpita has just implemented object constructors:

-- ft.code:
lang: ftd

\-- object obj:
function: console-print
value: Hello World

-- ft.markdown:

With this now you can construct JSON objects, eg above will create:

-- ft.code:
lang: json

{
    "function": "console-print",
    "value": "Hello World"
}

-- ft.markdown:

And then you can pass the object to JavaScript using `message-host`, eg:

-- ft.code:
lang: ftd

\-- ftd.text: click me
$event-click$: message-host $obj

-- ft.markdown:

And in JavaScript you can write the consumer:

-- ft.code:
lang: js

window["console-print"] = function(v) {
    console.log(v.value);
}

-- ft.markdown:

This JS code has to be provided by the "FTD Host", eg FPM is one such FTD Host.
To create arbitrary functionality, FTD Host interface has to be implemented.


This is the basic. Soon the object constructor will be able to refer to other
variables in FTD, eg:

-- ft.code:
lang: ftd

\-- object obj:
function: console-print
value: $foo

-- ft.markdown:

Here we will use the value, and type of `$foo`, and that will be inserted in the
object.

-- ft.h2: Objects Are Opaque

One important point to note is that objects, once constructed, can not be
introspected from FTD. So you can not do:

-- ft.code:
lang: ftd

\-- integer f: $obj.value

-- ft.markdown:

Assuming `$object.value` is an `integer`, this may seem "reasonable", but we do
not allow it. At least for now. We are doing it for performance reason one can
say, also we are lazy, we do not yet have time to think though the implications
of it.

We are building this feature to pass data to JavaScript for now, so we are
committing to only the part of design that is minimally needed.

-- ft.h2: JS Evaluation

When we have variable references in the object, we will generate the following
object:

-- ft.code:
lang: json

{
    "object": {
        "function": "console-print",
        "value": "$foo"
    }
}


-- ft.markdown:

We have one option that we go through the object and find all values with `$foo`
pattern, and resolve them. We can also have `\$foo` to escape this behaviour.

Other option is to keep track of references:

-- ft.code:
lang: json

{
    "references": {
        "value": "$foo",
        "foo.bar[0].baz": "$baz"
    },
    "object": {
        "function": "console-print",
        "value": "$foo"
    }
}

-- ft.markdown:

In `references` we have "JSON-paths" to every key that is a reference. Its easy
to update the object by iterating it.

We will see which ends up being easier to implement.

-- ft.h2: Objects Are Only Constructed in JS

The optimization I was talking about, why we want things opaque in FTD is so that
we only write code to create "object" in JS, and we do not have to evaluate the
value of object in Rust at all.

-- ft.h2: JavaScript Is Not The Only Host Language

Currently we are writing our FTD Host implementations in JS, but tomorrow we
want to support Swift, Java, etc when FTD targets other platforms.

This is why FTD is trying to be a common language that will work everywhere, it
will be responsible for UI and all the core part of functionality, like search,
API access etc, has to be provided by host.

-- ft.h2: Objects Can Take Parameters

You may want to pass parameters to objects. Soon you will be able to do:

-- ft.code:
lang: ftd

\-- object console-print:
string message:
function: console-print
message: $message

\-- ftd.text: click me
$event-click$: message-host console-print:
> message: clicked!

\-- ftd.input:
$event-input$: message-host console-print:
> message: $VALUE


-- ft.markdown:

Other usage of object constructor that takes parameter would be:

-- ft.code:
lang: ftd

\-- object get-user-info:
string username:
$process$: http
url: https://github.com/api/user-info
method: POST
api-key: $api-key

\-- user-info info:
$processor$: get-user-info
username: amitu

-- ft.h2: `message-host` can now pass parameters to FTD Host

`message-host` till now used to accept a function name, and `ftd.js` used to call
that function.


-- ft.code:
lang: ftd

\-- ftd.text: click me
$event-click$: message-host foo

-- ft.markdown:

This will call a function named `window.foo()`.

But there was no way till now to pass arguments to that function. With the
latest changes done by Arpita now we can pass arguments as well:

-- ft.code:
lang: ftd

\-- object arg:
function: what-ever-function
name: jack
field: value

\-- ftd.text: click me
$event-click$: message-host $arg

-- ft.markdown:

With this we will call `window.what-ever-function` and pass it following object:

-- ft.code:
lang: json

{
    "function": "what-ever-function",
    "name": "jack",
    "field": "value"
}

-- ft.markdown:

We will soon allow including FTD variable references in the object, e.g.
`name: $name`. We will also make `function` optional, if it's not passed we will
assume the name of object, in the above example it was `arg`.

-- ft.h1: `$VALUE` on `ftd.input`, `$event-input$` and `$event-change`

Arpita added support for `$VALUE` special variable so now you can do:

-- ft.code:
lang: ftd

\-- optional string query:

\-- ftd.input:
placeholder: Type Something Here...
$event-input$: $query=$VALUE

\-- ftd.text: $query

-- ft.markdown:

With the above, whatever is typed in the input field is immediately reflected
in `$query`. See a [demo here](https://fifthtry.github.io/ftd/input.html).

We have two events, `$event-input$`, which happens as soon as a input is edited,
on key press, and `$event-change$`, which happens when the user presses Enter
after inputting, or if the input field loses focus.

The `$VALUE` special variable is only visible to the event handler of the above
two events.

-- ft.h2: Future Plans

In future we will add a few features:

-- ft.h3: `value`

-- ft.code:
lang: ftd

\-- ftd.input:
value: $query
$event-input$: $query=$VALUE

-- ft.markdown:

Note the `value` bound to a variable, every time the variable changes the value
of the input field would be updated. So you can control the value of one input
field with another for example.

-- ft.h3: `default`

-- ft.code:
lang: ftd

\-- ftd.input:
default: $query

-- ft.markdown:

`default` will be used to bind the value of an input field when the input field
is initialized, and any further changes done to `$query` would have no effect on
the input field.

-- ft.h3: `type`

We will also support `type` parameter so input field can be used to get `username`,
which hints the browser to use Password Manager etc, `email`, `password` etc,
similar to how HTML input works.

-- ft.h1: Missing Feature: Intra-Page Table Of Content

When a FTD generated page is created, it is currently not possible to create a
table of content based on headings in the page.

Many sites show a table of content somewhere, usually on the right, or sometime
at the beginning of the article after the intro etc. This requires us to query
the current page for data. Heading hierarchy is one such data. List of images,
tables, diagrams etc could be other such query. Maybe even list of all foot-notes,
links etc could be useful as well.

We have "region" to identify some of these things. The query should allow us to
query by region, and authors should use regions properly to set this up.

One way to query things is package-query feature that we are working on `fpm`.
But that is largely for querying information from the entire package. And while
one can use the same mechanism to also query for information in current page, it
puts a dependency on `fpm`. Since ftd has access to information in current page,
such a query can be conceivably be easily provided by FTD as well.

What would be the result to these queries? Since these queries are to power intra
page linking, they should return `#hash` for that specific DOM node. We auto
generate `id` for each heading as of now. We have to start generating IDs for
every interesting region.

So the query could return list of hash, title pairs. Each region will have to
be associated with some sort of text as well. In case of image, table etc it
could be caption. Else it the name of the object can be the title, e.g. for image
we will just show "image", or even "image 1" etc.

What about heading tree?

We already do heading tree detection, we can return a nested data structure based
on our query.

What all to include? We can pass a list of regions that we are interested in.

It has to be a `$processor$`. We can call it `page-query`, `package-query` for
entire package, page query for just the page.

-- ft.code:
lang: ftd

\-- ftd.toc-item list headers:
$processor$: page-query
regions: h1, h2, h3, h4, image, table

-- ft.markdown:

Where `ftd.toc-item` itself is a record:

-- ft.code:
lang: ftd

\-- record toc-item:
string title:
string url:
toc-item list children:

-- ft.markdown:

Implementing it requires two pass rendering. In first pass the data would be
wrong, an empty list, we will first construct the whole DOM tree. And then in
second pass we will do the query, and update the list with the result.

-- ft.h1: TODO, RELEASE Only Posts And So On

In org-mode it is possible to add some tags to headings, like a TODO, RELEASE
etc, and then do query on the tags, eg only show headings matching given tag.

Consider this journal page itself, there are a lot of future TODO like headings,
many announcements of some feature RELEASE and so on. Now imagine if there was
some way to have a selector where you click on TODO button and only the posts
with TODO tags are visible.

How would we do that? One easy way to do it is to create components like this:

-- ft.code:
lang: ftd

\-- optional string current-tag:

\-- ftd.text h1: $title
caption title:
string tags:
if: $current-tag is null | $tags contains $current-tag

-- ft.markdown:

This should be doable already with no feature requirements, other than the `|`,
the `or` expression support.

-- ft.h1: Tags In TOC

It would also be cool if we could show the tags in the TOC. But our type
`toc-item` does not have `tags`. `region` is a common property, available on
all ftd elements. Maybe we can add `tags` on all of them as well, and include
`tags` in `toc-item`? We should also add `region` to `toc-item`.

-- ft.h1: Min/Max And Other Constraints

I was reading up on asn1, and they have interesting feature:

-- ft.code:
lang: asn

Address ::= SEQUENCE {
   street-address UTF8String,
   country UTF8String -- see a note below,
   postal-code UTF8String
} ((WITH COMPONENTS {
       ...,
       country ("USA"),
       postal-code (PATTERN "[0-9]#5(-[0-9]#4)?")
    }
  | WITH COMPONENTS {
       ...,
       country ("Canada"),
       postal-code (PATTERN "[0-9][A-Z][0-9]
                                [A-Z][0-9][A-Z]")
    }
  ))


-- ft.markdown:

SEQUENCE is just a `record`, and it has three fields, and for `postal-code` they
have two different constraints applied, depending on the value of `country`
field, e.g. if `country` is `USA`, then `postal-code` must match the given pattern
and so on.

This is quite interesting. We have minimal form handling support now, so user
is going to type stuff, and it would be good if we can chose to not accept
invalid values.

Similarly for components and theme configuration variables theme and component
authors should be able to place some restrictions on the values passed to them.

How could could it look like? First of all it has to be done at both top level,
and inside component level. So like `-- container:`, which can equally well work
with `--- container:`, meaning it should not have nesting. If we look at ASN1
example there is clear nesting. I mean if there was no nesting it would be easier
to design. Lets see.

Say:

-- ft.code:
lang: ftd

\-- string foo: hello
\-- check foo:
regex: <some regex>

-- ft.markdown:

So I am proposing a `check` keyword. We could have called it `constraint foo`
as well, but that's longer to type and I keep forgetting the spelling.

We can do it on record as well:

-- ft.code:
lang: ftd

\-- record foo:
string title:

\--- check title:
regex: <whatever>

-- ft.markdown:

And for components:

-- ft.code:
lang: ftd

\-- ftd.text foo:
caption title:

\--- check title:
regex: <whatever>

-- ft.markdown:

Types of checks will vary based on type of thing being checked. For string we
have `regex`. But we can have `max-length`, `min-length`, `starts-with`,
`ends-with`, `is-lower-case`, `is-title-case`, `contains`/`at-most-one` and so
on. Maybe even `unicode-range` stuff we use for `font-face`.

Similarly `integer` can be `min`, `max`, `is-odd: true`, `is-prime`? etc.

`contains`, `min`/`max` etc can also refer to other variables. How would we
disambiguate global vs local variables by same name? We won't. Don't overwrite
shadow variables, it's not a good idea, we will put a lint for that.

How would we know if the value is failing? In some cases we can create errors,
so if an invalid value was part of a document we can refuse to save the document
etc. But sometimes, e.g. when I am say changing a `boolean`, and based on new
value of the `boolean` a bunch of variables that were initially valid are no
longer valid. How do we deal with that?

One option is we accept the error case, and for each variable we have a special
attribute `.error`, which can be `optional string`, will be `null` if the
variable checks pass, else it would be the user visible error message.

Error message in what language? We can't pretend there is only one language now
can we? Especially when first class translation support is our one of shining
features in `fpm`? Problem for tomorrow me!

`-- check` can specify some error message as well if the check fails. What if
there are more than one errors? Make it `.errors`, like Django forms? Auto
message, e.g. failure of `min`, we can create an error message in right language.

-- ft.h1: Thoughts On Internationalization in FTD

BTW this takes us to need for ftl, Fluent, like way to translate stuff, when
we are creating component libraries, we are going to have to hard code strings,
and given we have first class `markup` support, we can create string templates
in every language for some string, and use variable substitution etc.

-- ft.code:
lang: ftd

\-- ftd.text welcome-message:
string who:
text if $fpm.lang == en: Hello, {$who}

\--- text:
if $fpm.lang == hi:

‡§®‡§Æ‡§∏‡•ç‡§§‡•á {$who},

‡§Ü‡§™‡§∏‡•á ‡§Æ‡§ø‡§≤ ‡§ï‡§∞ ‡§¨‡§π‡•Å‡§§ ‡•ô‡•Å‡§∂‡•Ä ‡§π‡•Å‡§à.

-- ft.markdown:

Some polish is needed in the syntax, but I think it can be made to work without
adding any new feature to FTD for translation.

-- ft.h1: `$event-click$: message-host <>`

23rd Dec 2021

Arpita just implemented [`message-host` event handler](/ftd/~/127/) support. Now
the "ftd host" (we will rename `ftd::Library` to `ftd::Host` terminology soon), can
define a JavaScript function (and in future when we support iOS etc, register Swift
function etc) and call it as event handler from FTD documents:


-- ft.code: defining the `foo()` host method
lang: js

window.foo = function() {
    console.log("foo");
}


-- ft.code: calling the `foo()` host method
lang: ftd

\-- ftd.text: call foo
$event-click$: message-host foo


-- ft.markdown:

Current we do not pass any arguments to the function. In future, when [json
constructor](/ftd/~/122/) is ready we would be able to pass FTD variables to host
functions.


-- ft.h1: Giving up on Special Variables

6th Dec 2021

Was writing a CR about ["fpm actions"](https://www.fifthtry.com/fpm/~/24/), and my
initial thought was to expose form errors using special variables, but then I
realised we do not have a mechanism to register for changes in [special
variables](/ftd/~/121/).

Variable change can only happen on client (it can still be triggered by server
and sent to client, eg on WebSocket). We are going to have `fpm.js` file to handle
those variables. We already have methods in `ftd.js` to update any variable, and
already have variable dependency tracker that updates the rendered DOM tree in an
efficient way.


-- ft.h2: What about "heavy variables"?

If we are creating regular variables, do we create a single virtual document that
exposes all the variables? Wouldn't computing that document be expensive? What if
we do not even use them?

One simple answer is to not have a single virtual document, but have a bunch of
document, maybe even one document per variable in extreme case. So we only import
the document that we want to use.

We will also have a linter that will complain if a document is imported but not
used, (and therefore we have [`import: foo as _`](///ftd.dev/~/44/) syntax).


-- ft.h2: "FTD Host"

FPM is proving to be a very good playground to explore what is the meaning of a FTD
Host. We have the `.get()` method, and FPM is putting a lot of interesting logic
in it, so this part of design is proving fruitful. Then we need special documents
for "generated" variables, and ftd host will take care of updating them on client
if needed.

FPM also exposes processors, and that's also working out quite well, there are very
FPM specific processors.

This does mean there is issue with portability of FTD documents between different
"FTD Hosts", would we have more than one hosts of FPM would be the only host?

We have at least one contender for next FTD host: arbit pages. If you want to use
ftd to power say your homepage (without using `fpm-repo`), and you must consider,
you are going to need your own variables with your own way of fetching documents
and your own


-- ft.h1: Unified Component Syntax

3rd Dec 2021

Arpita has implemented a unified syntax for component creation.


-- ft.code: old syntax
lang: ftd

\-- ftd.row foo:
spacing: 20


-- ft.code: new syntax
lang: ftd

\-- ftd.row foo:
spacing: 20


-- ft.markdown:

This was done to make it uniform with declaring variables:


-- ft.code:
lang: ftd

\-- integer bar: 20


-- ft.markdown:

Declaring something new is now always `<type> <name>:`, both for variables, records
and components, as well as for fields and argument definition in records and
components.


-- ft.h1: Backward Compatibility Guarantee

We hope this was the last backward incompatible change. We are now going to become
very careful about backward compatibility. We are not yet 1.0, and we expect at
least one major backward incompatible change before we really are ready for
production, but we are now going to avoid it as much as we can.


-- ft.h1: UI As A Type

Arpita has implemented UI as a type. Now a component can take another ui element
as an argument. Till now they could only accept data types.


-- ft.code:
lang: ftd

\-- ftd.column foo:
ftd.ui a:
integer size: 10

\--- a:


-- ft.markdown:

We have introduced a new type, `ftd.ui`, the argument `a` for component `foo` here
has type `ftd.ui`.

Any ftd kernel component can be passed to someone expecting a `ftd.ui`.


-- ft.code:
lang: ftd

\-- foo:
a: ftd.text: hello


-- ft.markdown:

Here we are passing `ftd.text: hello` to `foo` as `a`. We have also implemented
what we call "continuation" to pass parameters:


-- ft.code:
lang: ftd

\-- foo:
a: ftd.text: hello
> size: 20
size: 12


-- ft.markdown:

Here we have passed `size` to both `foo`, `size: 12` goes to `foo`, and to
`ftd.text`, `> size: 20` means we are continuing from the previous line, and hence
`size: 20` is passed to `ftd.text`.

We can do arbitrary nesting this way.


-- ft.code:
lang: ftd

\-- foo:
a: foo:
> a: foo:
>> a: ftd.text: hello
>>> size: 12
>> size: 30
> size: 20
size: 12


-- ft.markdown:

And so on. Of course this makes things harder to understand, so use this with
that in mind, don't over do it, break down things into smaller components, code is
read way more often than it is written, a little bit of extra effort goes a long
way keeping things easy.


-- ft.h1: `$var` Everything Is Done

25th Nov 2021

We finished implementation of $ for all variable.


-- ft.h1: New Component Syntax

We are now working on unified component / variable declaration syntax. Currently
our components are defined like this:


-- ft.code:
lang: ftd

\-- ftd.text foo:
text: some text


-- ft.markdown:

We are now going to use the following syntax for the same:


-- ft.code:
lang: ftd

\-- ftd.text foo:
text: some text


-- ft.markdown:

As you can see its simpler. It aligns with how we declare a variable:


-- ft.code:
lang: ftd

\-- integer bar: 20


-- ft.h1: Components as type

Currently a component can only accept basic data types, like integer and string,
but not other components. We are now going to use component as type:


-- ft.code:
lang: ftd

\-- ftd.row foo:
ftd.text child:

\-- foo:
child: ftd.text: hello


-- ft.markdown:

Here we have `child` of type `ftd.text`.


-- ft.h2: Thoughts On UI Types

Can only kernel types be used for UI type or any component? Ideally we should be
able to specify a component, and any direct invocation of that component, or any
other component that uses that component as a base should be passed? What if I
wanted a `ftd.row`, but the component derived from a `ftd.row` is no longer
`row-like`? Why do I want a row specifically? It kind of does not make sense? Maybe
I want a container, in which case I may be adding children to that container, which
means I have to have generic types like `ftd.element`, which accepts any ui element,
or `ftd.container`, which accepts a container.

What about `ftd.image`? What if I want to say give me an image. I can pass any
instance ftd.image or instance of a component created directly or indirectly from
ftd.image. But what about a row that wraps an image? Should that row not be
accepted by a component that is expecting image? Why would any component want to
accept an image specifically?


-- ft.h1: Started FPM: FTD Package Manager

FTD is an awesome language, and it deserves a kick-ass package manager. Today you
can not launch a language without a package manager. So we have started working on
[`fpm`](/fpm/).


-- ft.h1: FTD Logo

Jay has created a logo for FTD that we like:


-- ft.image:
src: https://i.imgur.com/eaxBC1d.jpg
width: 300
align: center


-- ft.h1: `try.ftd.dev`

We movee `play.fifthtry.com` to [`try.ftd.dev`](https://try.ftd.dev),now that
`ftd` docs are moving to [`ftd.dev`](https://ftd.dev). They will still use
FifthTry, just the domain would be custom.


-- ft.h1: [`$var` Everything](/ftd/~/105/) Update

15th Nov 2021

Arpita has partially implemented `$var` everywhere change. As of now, global
variables can be referred using `$foo` syntax, no need to use `ref`. Also `@foo`
syntax is gone, any `$foo` is editable as well.

What she is working now is external variables, you can define a variable on top of
a component:


-- ft.code:
lang: ftd

\-- ftd.row:
$foo: boolean with default false


-- ft.markdown:

Once external variable is done she has to fix the `boolean with default false` syntax
and use `boolean $foo: false` or even `$foo: false` to declare a variable.


-- ft.h1: clean api CR

15th Nov 2021

Wrote about my thoughts on cleaning up FTD [public crate api](/ftd/~/108/).


-- ft.h1: `detached` support proposal

13th Nov 2021


-- ft.iframe:
src: https://www.loom.com/embed/07681c220abd4eb584c75327c686360b


-- ft.markdown:

Wrote up a [CR for `detached` components](/ftd/~/106/): components that are not
part of UI when created, and added a new `include` keyword to include any detached
component in "current container".


-- ft.h1: Started Journal

13th Nov 2021


-- ft.iframe:
src: https://www.loom.com/embed/dd33e35449f64963ac694155b3ed88e0


-- ft.markdown:

We have decided to start a journal for FTD. FTD has been under a lot of development
and its good for us to record our daily development.

We have been keeping a personal journal in FifthTry internal documentation, but
it would be better if it moved all FTD related things here for everyone's benefit.

We kind of believe in writing down our thoughts during all meetings as much as we
can, etc, a lot of stuff we write in change requests, linked from the Roadmap page.
But since they are all scattered across different CRs, its not easy to keep up
with what is going on with the project, so we kind of want to duplicate or link
here what is going on.

We also want to create a loom recording after the fact, just to capture a few more
things we might have missed when writing it down.


-- ft.h1: Fix: spacing issue

12th Nov 2021


-- ft.iframe:
src: https://www.loom.com/embed/23000f3b4fc442f988181c5ff65c7949


-- ft.markdown:

Consider the following code:


-- ft.code:
lang: ftd

\-- var show: true

\-- foo:

\--- ftd.text: Hello üëã
if: show

\--- ftd.text: World üåé

\-- ftd.text: Click here!
$event-click$: toggle show

\-- component foo:
component: ftd.column
open: some-id

\--- ftd.text: Title

\--- ftd.row:
spacing: 20
id: some-id


-- ft.markdown:

This is how the DOM structure should look like:


-- ftd.scene:
height: 400


-- box:
left: 20
top: 20
width: 500
height: 300


-- text: `ftd.main` (`ftd.column`)
left: 290
top: 323


-- box:
left: 40
top: 40
width: 460
height: 200


-- text-box: Title
left: 55
top: 55


-- text: `ftd.row: some-id`
left: 300
top: 88


-- box:
width: 430
height: 80
top: 110
left: 55


-- text: `foo`
top: 215
left: 457


-- text-box: Hello üëã
top: 130
left: 70


-- text-box: World üåé
top: 130
left: 200


-- ftd.text: Click Here!
top: 250
left: 45


-- ftd.text text:
caption text:
text: $text


-- ftd.column box:
string width:
width: $width
string height:
height: $height
border-width: 1
border-radius: 5
open: false


-- ftd.text text-box:
caption text:
text: $text
padding: 10
border-width: 1
border-radius: 5


-- container: page


-- boolean show: true


-- ft.markdown:

This is how it should look like:


-- foo:

--- ftd.text: Hello üëã
if: $show

--- ftd.text: World üåé


-- ftd.text: Click here!
$event-click$: toggle $show


-- ftd.column foo:
open: some-id

--- ftd.text: Title

--- ftd.row:
spacing: 20
id: some-id


-- ft.markdown:

And this is how it used to look like:


-- ft.image:
src: https://i.imgur.com/7vypfBR.jpg
width: 130


-- ft.markdown:

There were two issues for proper rendering of the above code:

1. `--- ftd.text: Hello üëã` and `--- ftd.text: World üåé` are two external children
of component `foo` and `foo` is open at `--- ftd.row:`. Earlier we used to wrap all
the external children in a column component (Why not row? no good reason just that
column is used a lot) and then attach this wrapper component to the desired place.
So this created a problem here. Instead of children appearing in a row-wise fashion,
it appears column-wise.

2. Also, open container `ftd.row` has `spacing: 20` which means all its children would
contain spacing from each other, except the first visible one, but here it has only
one wrapper child, so no spacing.


-- ft.h2: How have we solved this?

Just remove the wrapper and put all external children directly inside the desired
node. But how would we do reparenting of them (like in the case of event handling)?
Put a new attribute (`data-ext-id`) that has the same value in all the external
children and during reparenting, access children using this attribute.


-- ft.h2: Is everything solved?

Not yet. In the case of event-handling, what if the first child becomes invisible
or removed and so what about spacing then?

As we know there should be no space for the first element, so now that the first
child has vanished, the second child should act as the first one and space
should be removed. (And obviously, when the first child becomes visible again,
the second one should restore the spacing.)

Here's the solution. We have added a new attribute (`data-spacing`) in the
parent node that contains the spacing value. Every time this kind of event occurs,
we reevaluate spacing for its children.


-- ft.h2: Are we done now?

Yes, all problems are resolved. üéâ üéä


-- ft.h1: Image link Fix

Fri, 12th Nov 2012

Consider the following code:


-- ft.code:
lang: ftd

\-- ftd.image:
src: https://www.w3schools.com/cssref/img_tree.gif
link: https://www.amitu.com/fifthtry/amitu/


-- ft.markdown:

Earlier, the link was not working. We just fixed this issue.


-- ft.h2: What was the issue?

For link we use `<a>` tag and for image we use `<img>` tag. `<img>` tag was
overriding `<a>`. Basically we were attaching `href` on top of `img` tag.


-- ft.h2: How have we resolved?

Now we create `<img>` tag and make it child of `<a>`.
