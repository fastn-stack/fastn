// Document path constructors are now auto-generated by the derive macro:
// - rig_config_path() for RigConfig
// - entity_status_path() for EntityStatus

#[derive(
    Debug,
    Clone,
    PartialEq,
    serde::Serialize,
    fastn_automerge::Reconcile,
    fastn_automerge::Hydrate,
    fastn_automerge::Document,
)]
#[document_path("/-/rig/{id52}/config")]
pub struct RigConfig {
    /// The rig's own public key (for document ID)
    #[document_id52]
    pub rig: fastn_id52::PublicKey,
    /// The rig owner's public key (who controls this rig)
    pub owner: fastn_id52::PublicKey,
    /// Unix timestamp when the rig was created
    pub created_at: i64,
    /// The current active entity
    pub current_entity: fastn_id52::PublicKey,
    /// Email certificate configuration 
    pub email_certificate: EmailCertificate,
}

// Additional methods for RigConfig beyond basic CRUD
impl RigConfig {
    pub fn update_current_entity(
        db: &fastn_automerge::Db,
        rig_id52: &fastn_id52::PublicKey,
        entity: &fastn_id52::PublicKey,
    ) -> Result<(), fastn_rig::CurrentEntityError> {
        // Use derive macro pattern instead of deprecated modify
        let mut config = Self::load(db, rig_id52).map_err(|e| {
            fastn_rig::CurrentEntityError::DatabaseAccessFailed {
                source: Box::new(e) as Box<dyn std::error::Error + Send + Sync>,
            }
        })?;
        config.current_entity = *entity;
        config
            .update(db)
            .map_err(|e| fastn_rig::CurrentEntityError::DatabaseAccessFailed {
                source: Box::new(e) as Box<dyn std::error::Error + Send + Sync>,
            })?;
        Ok(())
    }

    pub fn get_current_entity(
        db: &fastn_automerge::Db,
        rig_id52: &fastn_id52::PublicKey,
    ) -> Result<fastn_id52::PublicKey, fastn_rig::CurrentEntityError> {
        let config = Self::load(db, rig_id52).map_err(|e| {
            fastn_rig::CurrentEntityError::DatabaseAccessFailed {
                source: Box::new(e) as Box<dyn std::error::Error + Send + Sync>,
            }
        })?;
        Ok(config.current_entity)
    }
}

/// Email certificate configuration
#[derive(Debug, Clone, PartialEq, serde::Serialize, fastn_automerge::Reconcile, fastn_automerge::Hydrate)]
pub enum EmailCertificate {
    /// Self-signed certificates stored in stable filesystem location (not synced)
    /// Certificates generated per-connection IP and cached on disk
    SelfSigned,
    
    /// External certificate configuration for domain owners (synced via automerge)
    External {
        /// Certificate content or file path configuration
        certificate: ExternalCertificateSource,
        /// Domain name for the certificate
        domain: String,
        /// Unix timestamp when certificate was last loaded/updated
        last_updated: i64,
        /// Generate self-signed if external certificate fails
        fallback_to_self_signed: bool,
    },
}

/// External certificate source - either file paths or certificate content
#[derive(Debug, Clone, PartialEq, serde::Serialize, fastn_automerge::Reconcile, fastn_automerge::Hydrate)]
pub enum ExternalCertificateSource {
    /// File paths to certificate and key (nginx coexistence scenario)
    FilePaths {
        cert_path: String,
        key_path: String,
        auto_reload: bool,  // Watch for file changes
    },
    /// Certificate content stored directly in automerge (remote management scenario)
    Content {
        cert_pem: String,
        key_pem: String,
    },
}

#[derive(
    Debug,
    Clone,
    PartialEq,
    serde::Serialize,
    fastn_automerge::Reconcile,
    fastn_automerge::Hydrate,
    fastn_automerge::Document,
)]
#[document_path("/-/entities/{id52}/status")]
pub struct EntityStatus {
    /// The entity's public key (for document ID)
    #[document_id52]
    pub entity: fastn_id52::PublicKey,
    /// Whether the entity is currently online
    pub is_online: bool,
    /// Unix timestamp when the status was last updated
    pub updated_at: i64,
}

// Additional methods for EntityStatus beyond basic CRUD
impl EntityStatus {
    pub fn is_online(
        db: &fastn_automerge::Db,
        entity_id52: &fastn_id52::PublicKey,
    ) -> Result<bool, fastn_rig::EntityStatusError> {
        match Self::load(db, entity_id52) {
            Ok(status) => Ok(status.is_online),
            Err(_) => Ok(false), // Default to offline if document doesn't exist
        }
    }

    pub fn set_online(
        db: &fastn_automerge::Db,
        entity_id52: &fastn_id52::PublicKey,
        online: bool,
    ) -> Result<(), fastn_rig::EntityStatusError> {
        // Load existing document or create new one
        let mut status = match Self::load(db, entity_id52) {
            Ok(status) => status,
            Err(_) => {
                // Create new status document
                Self {
                    entity: *entity_id52,
                    is_online: false,
                    updated_at: 0,
                }
            }
        };

        // Update status
        status.is_online = online;
        status.updated_at = std::time::SystemTime::now()
            .duration_since(std::time::UNIX_EPOCH)
            .unwrap()
            .as_secs() as i64;

        // Save document
        status
            .save(db)
            .map_err(|e| fastn_rig::EntityStatusError::DatabaseAccessFailed {
                source: Box::new(e) as Box<dyn std::error::Error + Send + Sync>,
            })?;
        Ok(())
    }
}
