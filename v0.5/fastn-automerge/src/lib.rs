//! # fastn-automerge
//!
//! A high-level interface for working with Automerge CRDT documents stored in SQLite.
//! Provides type-safe document operations through derive macros with automatic path management.
//!
//! ## Three APIs Generated by `#[derive(Document)]`
//!
//! The derive macro generates different APIs based on your document definition:
//!
//! ### 1. Template-based API (with `{id52}` placeholder)
//!
//! When you provide a template with `{id52}`, you get the most convenient API:
//!
//! ```rust
//! use fastn_automerge::{Db, Document, Reconcile, Hydrate};
//! use fastn_id52::PublicKey;
//!
//! #[derive(Debug, Clone, serde::Serialize, Document, Reconcile, Hydrate)]
//! #[document_path("/-/users/{id52}/profile")]
//! struct UserProfile {
//!     #[document_id52]
//!     id: PublicKey,
//!     name: String,
//!     bio: Option<String>,
//! }
//!
//! # fn main() -> Result<(), Box<dyn std::error::Error>> {
//! # let temp_dir = tempfile::TempDir::new()?;
//! # let db_path = temp_dir.path().join("test.db");
//! # let entity = fastn_id52::SecretKey::generate().public_key();
//! # let db = Db::init(&db_path, &entity)?;
//! let user_id = fastn_id52::SecretKey::generate().public_key();
//! let user = UserProfile {
//!     id: user_id,
//!     name: "Alice".to_string(),
//!     bio: Some("Developer".to_string()),
//! };
//!
//! // Template-based operations (no path needed)
//! user.save(&db)?;                           // Uses /-/users/{id52}/profile
//! let loaded = UserProfile::load(&db, &user_id)?;
//! 
//! // List all user profiles with exact DNSSEC32 validation
//! let all_users = UserProfile::document_list(&db)?;  // Only when {id52} present
//! println!("Found {} users", all_users.len());
//! # Ok(())
//! # }
//! ```
//!
//! ### 2. Singleton API (template without `{id52}`)
//!
//! For singleton documents, you get simple operations:
//!
//! ```rust
//! # use fastn_automerge::{Db, Document, Reconcile, Hydrate};
//! #[derive(Debug, Clone, serde::Serialize, Document, Reconcile, Hydrate)]
//! #[document_path("/-/app/settings")]
//! struct AppSettings {
//!     theme: String,
//!     debug_mode: bool,
//! }
//!
//! # fn main() -> Result<(), Box<dyn std::error::Error>> {
//! # let temp_dir = tempfile::TempDir::new()?;
//! # let db_path = temp_dir.path().join("test.db");
//! # let entity = fastn_id52::SecretKey::generate().public_key();
//! # let db = Db::init(&db_path, &entity)?;
//! let settings = AppSettings {
//!     theme: "dark".to_string(),
//!     debug_mode: true,
//! };
//!
//! // Singleton operations (no ID parameter needed)
//! settings.save(&db)?;                     // Uses /-/app/settings
//! let loaded = AppSettings::load(&db)?;
//! // No document_list() - only one instance possible
//! # Ok(())
//! # }
//! ```
//!
//! ### 3. Path-based API (no template)
//!
//! For maximum flexibility, require explicit paths:
//!
//! ```rust
//! # use fastn_automerge::{Db, Document, DocumentPath, Reconcile, Hydrate};
//! # use fastn_id52::PublicKey;
//! #[derive(Debug, Clone, serde::Serialize, Document, Reconcile, Hydrate)]
//! struct FlexibleDoc {
//!     #[document_id52]
//!     id: PublicKey,
//!     data: String,
//! }
//!
//! # fn main() -> Result<(), Box<dyn std::error::Error>> {
//! # let temp_dir = tempfile::TempDir::new()?;
//! # let db_path = temp_dir.path().join("test.db");
//! # let entity = fastn_id52::SecretKey::generate().public_key();
//! # let db = Db::init(&db_path, &entity)?;
//! let doc_id = fastn_id52::SecretKey::generate().public_key();
//! let doc = FlexibleDoc {
//!     id: doc_id,
//!     data: "flexible data".to_string(),
//! };
//!
//! // Path-based operations (explicit path required)
//! let path = DocumentPath::from_string("/-/custom/location")?;
//! doc.save(&db, &path)?;
//! let loaded = FlexibleDoc::load(&db, &path)?;
//! // No document_list() - no pattern to match against
//! # Ok(())
//! # }
//! ```
//!
//! ## Key Features
//!
//! - **CRDT support**: Built on Automerge for conflict-free collaborative editing
//! - **Type safety**: Compile-time path validation and type checking  
//! - **Smart path management**: Three different APIs for different use cases
//! - **Exact pattern matching**: `document_list()` uses precise DNSSEC32 validation
//! - **SQLite storage**: Efficient persistence with SQL optimization
//! - **Actor ID management**: Automatic device/entity tracking for privacy
//! - **Feature-gated CLI**: Optional command-line tools for database inspection
//!
//! ## Database Setup
//!
//! ```rust
//! use fastn_automerge::Db;
//! use std::path::Path;
//!
//! # fn main() -> Result<(), Box<dyn std::error::Error>> {
//! # let temp_dir = tempfile::TempDir::new()?;
//! # let db_path = temp_dir.path().join("test.db");
//! // Initialize new database
//! let entity = fastn_id52::SecretKey::generate().public_key();
//! let db = Db::init(&db_path, &entity)?;
//!
//! // Or open existing database  
//! let db = Db::open(&db_path)?;
//! # Ok(())
//! # }
//! ```

extern crate self as fastn_automerge;

// Private modules
#[cfg(feature = "cli")]
pub mod cli;
mod migration;
#[cfg(test)]
mod tests;
mod utils;

// Public modules with specific error types
pub mod db;

// Essential re-exports for derive macro usage
pub use autosurgeon::{Hydrate, Reconcile};
pub use fastn_automerge_derive::Document;

// Test utilities
pub use utils::create_test_db;

// =============================================================================
// Core Types
// =============================================================================

/// Error when parsing document paths
#[derive(Debug, Clone, PartialEq, thiserror::Error)]
pub enum DocumentPathError {
    #[error("Document path cannot be empty")]
    Empty,
    #[error("Document path can contain at most one '/-/' prefix, found {count}")]
    TooManyPrefixes { count: usize },
}

/// Validated document path for database operations
#[derive(Debug, Clone, PartialEq)]
pub struct DocumentPath(String);

impl DocumentPath {
    /// Create document path from string with validation
    pub fn from_string(id: &str) -> std::result::Result<Self, DocumentPathError> {
        if id.is_empty() {
            return Err(DocumentPathError::Empty);
        }

        let slash_dash_count = id.matches("/-/").count();
        if slash_dash_count > 1 {
            return Err(DocumentPathError::TooManyPrefixes {
                count: slash_dash_count,
            });
        }

        Ok(Self(id.to_string()))
    }

    pub fn as_str(&self) -> &str {
        &self.0
    }
}

impl rusqlite::ToSql for DocumentPath {
    fn to_sql(&self) -> rusqlite::Result<rusqlite::types::ToSqlOutput<'_>> {
        self.0.to_sql()
    }
}

impl std::fmt::Display for DocumentPath {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.0)
    }
}

// =============================================================================
// Database
// =============================================================================

/// Main database interface for Automerge documents
pub struct Db {
    pub(crate) conn: rusqlite::Connection,
    pub(crate) entity: fastn_id52::PublicKey,
    pub(crate) device_number: u32,
    #[allow(dead_code)] // clippy false positive: used in next_actor_id()
    pub(crate) mutex: std::sync::Mutex<()>,
}

impl Db {
    /// Get the full actor ID string
    pub fn actor_id(&self) -> String {
        format!("{}-{}", self.entity, self.device_number)
    }

    /// Update device number (can only be called from device 0 to assign new device numbers)
    pub fn update_device_number(
        &mut self,
        new_device_number: u32,
    ) -> std::result::Result<(), DeviceNumberError> {
        if self.device_number != 0 {
            return Err(DeviceNumberError::NotPrimaryDevice);
        }
        if new_device_number == 0 {
            return Err(DeviceNumberError::InvalidDeviceNumber);
        }
        self.device_number = new_device_number;
        Ok(())
    }
}

#[derive(Debug, Clone, PartialEq, thiserror::Error)]
pub enum DeviceNumberError {
    #[error("Only primary device (0) can assign new device numbers")]
    NotPrimaryDevice,
    #[error("Invalid device number: must be greater than 0")]
    InvalidDeviceNumber,
}

impl std::fmt::Debug for Db {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("Db")
            .field("entity", &self.entity)
            .field("device_number", &self.device_number)
            .field("conn", &"<rusqlite::Connection>")
            .finish()
    }
}

// =============================================================================
// Advanced/Internal Types (for history inspection and system operations)
// =============================================================================

/// Internal actor counter for device ID management
#[derive(Debug, Clone, PartialEq, Reconcile, Hydrate, serde::Serialize)]
pub(crate) struct ActorCounter {
    pub entity_id52: String,
    pub next_device: u32,
}

/// Represents a single operation within an edit (for history inspection)
#[derive(Debug, Clone)]
pub enum Operation {
    /// Set a key to a value in a map
    Set {
        path: Vec<String>,
        key: String,
        value: String,
    },
    /// Delete a key from a map
    Delete { path: Vec<String>, key: String },
    /// Insert an item into a list
    Insert {
        path: Vec<String>,
        index: usize,
        value: String,
    },
    /// Delete an item from a list
    Remove { path: Vec<String>, index: usize },
    /// Increment a counter
    Increment {
        path: Vec<String>,
        key: String,
        delta: i64,
    },
}

/// Represents a single edit/change in an Automerge document's history
#[derive(Debug, Clone)]
pub struct Edit {
    pub index: usize,
    pub hash: String,
    pub actor_id: String,
    pub timestamp: i64,
    pub message: Option<String>,
    pub operations: Vec<Operation>,
}

/// Complete history of a document including metadata and all edits
#[derive(Debug)]
pub struct DocumentHistory {
    pub path: String,
    pub created_alias: String,
    pub updated_at: i64,
    pub heads: Vec<String>,
    pub edits: Vec<Edit>,
}

// =============================================================================
// CLI Entry Point
// =============================================================================

/// Main function for the CLI binary (hidden from docs)
#[cfg(feature = "cli")]
#[doc(hidden)]
pub fn main() {
    use clap::Parser;
    let cli: cli::Cli = cli::Cli::parse();

    if let Err(e) = cli::run_command(cli) {
        eprintln!("Error: {e}");
        std::process::exit(1);
    }
}