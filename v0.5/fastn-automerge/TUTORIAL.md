# fastn-automerge Tutorial

This tutorial covers the fastn-automerge library in detail, focusing on the three different APIs generated by the `#[derive(Document)]` macro.

## Table of Contents

1. [Introduction](#introduction)
2. [Three Document APIs](#three-document-apis)
3. [Template-based API](#template-based-api)
4. [Singleton API](#singleton-api)
5. [Path-based API](#path-based-api)
6. [Advanced Features](#advanced-features)
7. [Best Practices](#best-practices)

## Introduction

fastn-automerge provides a high-level interface for working with Automerge CRDT documents stored in SQLite. The `#[derive(Document)]` macro generates different APIs based on how you structure your document definitions.

### When to Use fastn-automerge

- Building distributed/P2P applications that need eventual consistency
- Managing configuration that can be edited from multiple sources
- Storing documents that need full version history
- Applications requiring offline-first capabilities

## Three Document APIs

The `#[derive(Document)]` macro generates three different APIs depending on your document structure:

| API Type | When Used | Generated Functions | Use Case |
|----------|-----------|-------------------|----------|
| **Template-based** | `#[document_path("/-/users/{id52}/profile")]` | `save(db)`, `load(db, &id)`, `document_list(db)` | Entity-specific documents |
| **Singleton** | `#[document_path("/-/app/settings")]` | `save(db)`, `load(db)` | Global/config documents |
| **Path-based** | No `#[document_path]` attribute | `save(db, &path)`, `load(db, &path)` | Maximum flexibility |

## Template-based API

### Setup and Usage

```rust
use fastn_automerge::{Db, Document, Reconcile, Hydrate};
use fastn_id52::PublicKey;

#[derive(Debug, Clone, Document, Reconcile, Hydrate)]
#[document_path("/-/users/{id52}/profile")]
struct UserProfile {
    #[document_id52]
    user_id: PublicKey,
    name: String,
    bio: Option<String>,
    last_active: i64,
}

#[derive(Debug, Clone, Document, Reconcile, Hydrate)]
#[document_path("/-/projects/{id52}/metadata")]
struct ProjectMetadata {
    #[document_id52]
    project_id: PublicKey,
    title: String,
    description: String,
    tags: Vec<String>,
}
```

### Basic Operations

```rust
fn template_based_example(db: &Db) -> Result<(), Box<dyn std::error::Error>> {
    let user_id = fastn_id52::SecretKey::generate().public_key();
    
    // Create user profile
    let profile = UserProfile {
        user_id,
        name: "Alice".to_string(),
        bio: Some("Software Engineer".to_string()),
        last_active: chrono::Utc::now().timestamp(),
    };

    // Save (no path needed - uses template)
    profile.save(&db)?;

    // Load by ID (no path needed)
    let loaded = UserProfile::load(&db, &user_id)?;
    println!("Loaded user: {}", loaded.name);

    // Update
    let mut updated = loaded;
    updated.bio = Some("Senior Software Engineer".to_string());
    updated.update(&db)?;

    Ok(())
}
```

### Document Listing (NEW!)

The template-based API generates a `document_list()` function when `{id52}` is present:

```rust
fn list_users_example(db: &Db) -> Result<(), Box<dyn std::error::Error>> {
    // Create multiple users
    for i in 0..5 {
        let user_id = fastn_id52::SecretKey::generate().public_key();
        let profile = UserProfile {
            user_id,
            name: format!("User {}", i),
            bio: None,
            last_active: chrono::Utc::now().timestamp(),
        };
        profile.save(&db)?;
    }

    // List all user profiles with exact DNSSEC32 validation
    let user_paths = UserProfile::document_list(&db)?;
    println!("Found {} user profiles", user_paths.len());

    // Load all users
    for path in user_paths {
        // Extract ID from path and load (implementation depends on use case)
        if let Some(id_str) = extract_id52_from_path(&path) {
            if let Ok(user_id) = fastn_id52::PublicKey::from_string(&id_str) {
                let user = UserProfile::load(&db, &user_id)?;
                println!("User: {}", user.name);
            }
        }
    }

    Ok(())
}

fn extract_id52_from_path(path: &fastn_automerge::DocumentPath) -> Option<String> {
    // For path "/-/users/{id52}/profile", extract the ID part
    let path_str = path.as_str();
    if path_str.starts_with("/-/users/") && path_str.ends_with("/profile") {
        let id_start = "/-/users/".len();
        let id_end = path_str.len() - "/profile".len();
        Some(path_str[id_start..id_end].to_string())
    } else {
        None
    }
}
```

## Singleton API

### Setup and Usage

```rust
use fastn_automerge::{Db, Document, Reconcile, Hydrate};

#[derive(Debug, Clone, Document, Reconcile, Hydrate)]
#[document_path("/-/app/settings")]
struct AppSettings {
    theme: String,
    debug_mode: bool,
    max_users: usize,
}

#[derive(Debug, Clone, Document, Reconcile, Hydrate)]
#[document_path("/-/system/stats")]
struct SystemStats {
    startup_time: i64,
    total_requests: u64,
    active_users: u32,
}
```

### Operations

```rust
fn singleton_example(db: &Db) -> Result<(), Box<dyn std::error::Error>> {
    // Create global settings
    let settings = AppSettings {
        theme: "dark".to_string(),
        debug_mode: false,
        max_users: 1000,
    };

    // Save (uses fixed path /-/app/settings)
    settings.save(&db)?;

    // Load (no parameters needed)
    let loaded = AppSettings::load(&db)?;
    println!("Theme: {}", loaded.theme);

    // Update
    let mut updated = loaded;
    updated.debug_mode = true;
    updated.update(&db)?;

    // Note: No document_list() function - only one instance possible

    Ok(())
}
```

## Path-based API

### Setup and Usage

```rust
use fastn_automerge::{Db, Document, DocumentPath, Reconcile, Hydrate};
use fastn_id52::PublicKey;

#[derive(Debug, Clone, Document, Reconcile, Hydrate)]
struct FlexibleDoc {
    #[document_id52]
    id: PublicKey,
    content: String,
    metadata: std::collections::HashMap<String, String>,
}

#[derive(Debug, Clone, Document, Reconcile, Hydrate)]
struct GenericData {
    value: serde_json::Value,
    created_at: i64,
}
```

### Operations

```rust
fn path_based_example(db: &Db) -> Result<(), Box<dyn std::error::Error>> {
    let doc_id = fastn_id52::SecretKey::generate().public_key();
    let doc = FlexibleDoc {
        id: doc_id,
        content: "Flexible content".to_string(),
        metadata: std::collections::HashMap::new(),
    };

    // All operations require explicit path
    let path1 = DocumentPath::from_string("/-/custom/location/1")?;
    let path2 = DocumentPath::from_string("/-/backup/location/1")?;

    // Save to multiple locations
    doc.save(&db, &path1)?;
    doc.save(&db, &path2)?;

    // Load from specific path
    let loaded1 = FlexibleDoc::load(&db, &path1)?;
    let loaded2 = FlexibleDoc::load(&db, &path2)?;

    assert_eq!(loaded1.content, loaded2.content);

    // Update specific location
    let mut updated = loaded1;
    updated.content = "Updated content".to_string();
    updated.update(&db, &path1)?;

    // path2 remains unchanged
    let unchanged = FlexibleDoc::load(&db, &path2)?;
    assert_eq!(unchanged.content, "Flexible content");

    Ok(())
}
```

## Advanced Features

### Database Setup

```rust
use fastn_automerge::Db;
use std::path::Path;

fn setup_database() -> Result<Db, Box<dyn std::error::Error>> {
    // Initialize new database
    let entity = fastn_id52::SecretKey::generate().public_key();
    let db = Db::init(Path::new("app.sqlite"), &entity)?;

    // Or open existing database
    let db = Db::open(Path::new("app.sqlite"))?;

    Ok(db)
}
```

### Document History

```rust
fn history_example(db: &Db) -> Result<(), Box<dyn std::error::Error>> {
    let user_id = fastn_id52::SecretKey::generate().public_key();
    let path = UserProfile::document_path(&user_id);

    // Get complete document history
    let history = db.history(&path, None)?;
    println!("Document: {}", history.path);
    println!("Created by: {}", history.created_alias);
    println!("Edits: {}", history.edits.len());

    for edit in &history.edits {
        println!("Edit {}: {} operations by {}", 
                 edit.index, edit.operations.len(), edit.actor_id);
    }

    Ok(())
}
```

### Working with Multiple Document Types

```rust
fn multi_type_example(db: &Db) -> Result<(), Box<dyn std::error::Error>> {
    // Create user
    let user_id = fastn_id52::SecretKey::generate().public_key();
    let user = UserProfile {
        user_id,
        name: "Alice".to_string(),
        bio: Some("Developer".to_string()),
        last_active: chrono::Utc::now().timestamp(),
    };
    user.save(&db)?;

    // Create project
    let project_id = fastn_id52::SecretKey::generate().public_key();
    let project = ProjectMetadata {
        project_id,
        title: "My Project".to_string(),
        description: "A sample project".to_string(),
        tags: vec!["rust".to_string(), "crdt".to_string()],
    };
    project.save(&db)?;

    // Create global settings
    let settings = AppSettings {
        theme: "dark".to_string(),
        debug_mode: false,
        max_users: 100,
    };
    settings.save(&db)?;

    // List documents by type
    let user_paths = UserProfile::document_list(&db)?;
    let project_paths = ProjectMetadata::document_list(&db)?;
    // Note: AppSettings has no document_list() - it's a singleton

    println!("Users: {}, Projects: {}", user_paths.len(), project_paths.len());

    Ok(())
}
```

## Best Practices

### 1. Choose the Right API

**Use Template-based API when:**
- You have multiple instances of the same document type
- Documents are organized by entity/user ID
- You want automatic path management
- You need to list all documents of a type

**Use Singleton API when:**
- You have exactly one instance (config, settings, system state)
- The document represents global application state
- Path never changes

**Use Path-based API when:**
- You need maximum flexibility in path organization
- Documents don't follow a standard pattern
- You're migrating from an existing path structure
- You want explicit control over all paths

### 2. Document Organization

```rust
// Good: Clear hierarchy with templates
#[derive(Document, Reconcile, Hydrate)]
#[document_path("/-/users/{id52}/profile")]
struct UserProfile { /* ... */ }

#[derive(Document, Reconcile, Hydrate)]
#[document_path("/-/users/{id52}/settings")]
struct UserSettings { /* ... */ }

#[derive(Document, Reconcile, Hydrate)]
#[document_path("/-/projects/{id52}/metadata")]
struct ProjectMetadata { /* ... */ }

// Good: Singleton for global state
#[derive(Document, Reconcile, Hydrate)]
#[document_path("/-/app/config")]
struct AppConfig { /* ... */ }
```

### 3. Error Handling

```rust
use fastn_automerge::db::{GetError, CreateError, UpdateError};

fn robust_operations(db: &Db) -> Result<(), Box<dyn std::error::Error>> {
    let user_id = fastn_id52::SecretKey::generate().public_key();

    // Handle document not found
    match UserProfile::load(&db, &user_id) {
        Ok(profile) => println!("Found profile: {}", profile.name),
        Err(GetError::NotFound(_)) => {
            println!("Profile not found, creating default...");
            let profile = UserProfile {
                user_id,
                name: "New User".to_string(),
                bio: None,
                last_active: chrono::Utc::now().timestamp(),
            };
            profile.save(&db)?;
        }
        Err(e) => return Err(e.into()),
    }

    Ok(())
}
```

### 4. Performance Tips

```rust
fn performance_example(db: &Db) -> Result<(), Box<dyn std::error::Error>> {
    // Use document_list() for bulk operations
    let user_paths = UserProfile::document_list(&db)?;
    
    // Process in batches for large datasets
    for chunk in user_paths.chunks(100) {
        for path in chunk {
            if let Some(id_str) = extract_id52_from_path(path) {
                if let Ok(user_id) = fastn_id52::PublicKey::from_string(&id_str) {
                    // Process user...
                    let user = UserProfile::load(&db, &user_id)?;
                    // ... do something with user
                }
            }
        }
        // Optional: yield control between batches
        tokio::task::yield_now().await;
    }

    Ok(())
}
```

### 5. Testing

```rust
#[cfg(test)]
mod tests {
    use super::*;
    use fastn_automerge::create_test_db;

    #[test]
    fn test_user_operations() -> Result<(), Box<dyn std::error::Error>> {
        let (db, _temp_dir) = create_test_db()?;

        let user_id = fastn_id52::SecretKey::generate().public_key();
        let profile = UserProfile {
            user_id,
            name: "Test User".to_string(),
            bio: Some("Test bio".to_string()),
            last_active: 0,
        };

        // Test CRUD operations
        profile.create(&db)?;
        
        let loaded = UserProfile::load(&db, &user_id)?;
        assert_eq!(loaded.name, "Test User");

        let mut updated = loaded;
        updated.name = "Updated User".to_string();
        updated.update(&db)?;

        let final_profile = UserProfile::load(&db, &user_id)?;
        assert_eq!(final_profile.name, "Updated User");

        // Test listing
        let profiles = UserProfile::document_list(&db)?;
        assert_eq!(profiles.len(), 1);

        Ok(())
    }
}
```

## CLI Usage (Optional Feature)

To use the CLI tools, install with the CLI feature:

```bash
# Install with CLI support
cargo install fastn-automerge --features=cli

# Basic commands
fastn-automerge init
fastn-automerge create /-/test/doc '{"name": "example"}'
fastn-automerge get /-/test/doc --pretty
fastn-automerge list
fastn-automerge history /-/test/doc
```

For library users, the CLI dependencies are not included by default for smaller builds.

## Migration Guide

If you're upgrading from the old direct API (`db.create()`, `db.get()`), here's how to migrate:

### Old API (Deprecated)
```rust
// Old way - deprecated with warnings
let path = DocumentPath::from_string("/-/users/alice/profile")?;
db.create(&path, &user)?;
let loaded: User = db.get(&path)?;
```

### New API (Recommended)
```rust
// New way - clean and type-safe
#[derive(Document, Reconcile, Hydrate)]
#[document_path("/-/users/{id52}/profile")]
struct User { #[document_id52] id: PublicKey, /* ... */ }

user.save(&db)?;
let loaded = User::load(&db, &user_id)?;
```

## Troubleshooting

### Common Issues

1. **"No document_list function"**
   - **Cause**: Document template doesn't contain `{id52}`
   - **Solution**: Add `{id52}` to template or use singleton API

2. **"Function takes 2 arguments but 1 supplied"**
   - **Cause**: Using path-based API (no `#[document_path]`)
   - **Solution**: Add `DocumentPath` parameter or add template attribute

3. **"document_list returns empty results"**
   - **Cause**: Path pattern doesn't match stored documents
   - **Solution**: Check that stored paths match template exactly

4. **"Invalid document path"**
   - **Cause**: ID52 in path is not exactly 52 alphanumeric characters
   - **Solution**: Ensure proper DNSSEC32 format

### Performance Issues

- Use `document_list()` for bulk operations instead of manual path construction
- Process large result sets in chunks
- Consider using the low-level `db.list()` for custom filtering when needed

## Further Reading

- [Automerge Documentation](https://automerge.org/)
- [Autosurgeon Documentation](https://docs.rs/autosurgeon)
- [SQLite Best Practices](https://www.sqlite.org/bestpractice.html)
- [CRDT Introduction](https://crdt.tech/)