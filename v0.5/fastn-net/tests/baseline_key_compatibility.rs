//! Test compatibility with baseline keys generated by fastn keygen
//!
//! This test ensures that keys generated by baseline fastn-net/fastn
//! continue to work across versions. These tests should pass on both
//! the baseline version and future refactored versions.

use std::fs;
use std::str::FromStr;

#[test]
fn test_baseline_secret_keys_load_correctly() {
    // These are the actual keys generated by baseline malai keygen from commit 11d4d3f
    let baseline_keys = vec![
        (
            "../test-keys/key-1.txt",
            "100d7e23f222267ba0be43855a262461b8a7718572edf58c56db912156d2bc25",
            "i66fo538lfl5ombdf6tcdbrabp4hmp9asv7nrffuc2im13ct4q60",
        ),
        (
            "../test-keys/key-2.txt",
            "e357e8a31fa82958cf0a7697846cb9ed494807d5d8bf95bac9ed21207d8ce6a3",
            "e87aeds2fajaeu10tjdio5ppcdha410n6tu4665u7el9as9b7v80",
        ),
        (
            "../test-keys/key-3.txt",
            "a0ed7d4cdd3a2941a289f6bde83717898cccde35b0a8c2944aba66f87a2dcfa9",
            "mlk9ubnvu8r1sk06j4tjb98njra0od5d2dglpm8gubbvg4glthng",
        ),
    ];

    for (file_path, expected_hex, expected_id52) in baseline_keys {
        println!("Testing baseline key from {file_path}");

        // Read the key file generated by baseline malai keygen
        let key_content = fs::read_to_string(file_path)
            .unwrap_or_else(|_| panic!("Failed to read {file_path}"));
        let key_hex = key_content.trim();

        // Verify it matches expected hex
        assert_eq!(
            key_hex, expected_hex,
            "Key file content doesn't match expected for {file_path}"
        );

        // Parse the hex into bytes
        let key_bytes = hex::decode(key_hex)
            .unwrap_or_else(|_| panic!("Failed to decode hex key from {file_path}"));
        assert_eq!(key_bytes.len(), 32, "Key should be 32 bytes");

        // Create fastn_id52::SecretKey from hex string
        let secret_key = fastn_id52::SecretKey::from_str(key_hex)
            .unwrap_or_else(|_| panic!("Failed to parse secret key from {file_path}"));

        // Test that Display produces the same hex
        let display_hex = format!("{secret_key}");
        assert_eq!(
            display_hex, expected_hex,
            "Display encoding changed for {file_path}"
        );

        // Test that ID52 matches what baseline produced
        let public_key = secret_key.public_key();
        let id52 = public_key.to_string();
        assert_eq!(
            id52, expected_id52,
            "ID52 encoding changed for {file_path}"
        );

        // Test that we can parse the ID52 back
        let parsed_public = fastn_id52::PublicKey::from_str(&id52)
            .unwrap_or_else(|_| panic!("Failed to parse ID52: {id52}"));
        let roundtrip_id52 = parsed_public.to_string();
        assert_eq!(
            id52, roundtrip_id52,
            "ID52 roundtrip failed for {file_path}"
        );

        println!("  ✓ Key loads correctly, encoding preserved, ID52 matches");
    }

    println!("\n✅ All baseline keys work correctly with current implementation");
}

#[test]
fn test_secret_key_hex_format() {
    // Test the hex format expectation
    let test_hex = "100d7e23f222267ba0be43855a262461b8a7718572edf58c56db912156d2bc25";

    // Parse hex to bytes
    let bytes = hex::decode(test_hex).expect("Should decode valid hex");
    assert_eq!(bytes.len(), 32, "Should be 32 bytes");

    // Create secret key from hex string
    let secret_key = fastn_id52::SecretKey::from_str(test_hex).expect("Should parse valid hex");

    // Display should produce lowercase hex
    let display = format!("{secret_key}");
    assert_eq!(display, test_hex, "Display should produce lowercase hex");
    assert_eq!(display.len(), 64, "Should be 64 hex characters");

    // Should be all lowercase
    assert!(
        display
            .chars()
            .all(|c| c.is_ascii_hexdigit() && !c.is_ascii_uppercase()),
        "Should be lowercase hex"
    );

    println!("✅ Secret key hex format is correct");
}

#[test]
fn test_id52_format() {
    // Test the ID52 format expectation
    let test_id52 = "i66fo538lfl5ombdf6tcdbrabp4hmp9asv7nrffuc2im13ct4q60";

    // Should be 52 characters
    assert_eq!(test_id52.len(), 52, "ID52 should be 52 characters");

    // Should be valid BASE32_DNSSEC
    let decoded = data_encoding::BASE32_DNSSEC
        .decode(test_id52.as_bytes())
        .expect("Should be valid BASE32_DNSSEC");
    assert_eq!(decoded.len(), 32, "Decoded should be 32 bytes");

    // Roundtrip test
    let encoded = data_encoding::BASE32_DNSSEC.encode(&decoded);
    assert_eq!(encoded, test_id52, "Should roundtrip correctly");

    println!("✅ ID52 format is correct");
}

#[test]
fn test_generate_and_verify_new_key() {
    // Test that generation still works the same way
    let (id52, secret_key) =
        fastn_net::generate_secret_key().expect("Should generate key successfully");

    // Check formats
    let secret_hex = format!("{secret_key}");
    assert_eq!(secret_hex.len(), 64, "Secret should be 64 hex chars");
    assert_eq!(id52.len(), 52, "ID52 should be 52 chars");

    // Test consistency
    let public_key = secret_key.public_key();
    let derived_id52 = public_key.to_string();
    assert_eq!(id52, derived_id52, "ID52 should be consistent");

    println!("✅ Key generation works correctly");
}
