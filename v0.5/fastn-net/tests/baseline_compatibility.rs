//! Test to verify baseline keys (generated with old version) work with current implementation

use std::str::FromStr;

#[test]
fn test_baseline_keys_compatibility() {
    // These are the actual keys generated by baseline malai keygen
    let baseline_keys = vec![
        (
            "100d7e23f222267ba0be43855a262461b8a7718572edf58c56db912156d2bc25",
            "i66fo538lfl5ombdf6tcdbrabp4hmp9asv7nrffuc2im13ct4q60",
        ),
        (
            "e357e8a31fa82958cf0a7697846cb9ed494807d5d8bf95bac9ed21207d8ce6a3",
            "e87aeds2fajaeu10tjdio5ppcdha410n6tu4665u7el9as9b7v80",
        ),
        (
            "a0ed7d4cdd3a2941a289f6bde83717898cccde35b0a8c2944aba66f87a2dcfa9",
            "mlk9ubnvu8r1sk06j4tjb98njra0od5d2dglpm8gubbvg4glthng",
        ),
    ];

    println!("\nTesting baseline keys with current fastn-net...");

    for (key_hex, expected_id52) in baseline_keys {
        println!("\n  Testing key: {}...", &key_hex[..16]);

        // Parse the baseline key with current version
        let secret_key = fastn_id52::SecretKey::from_str(key_hex)
            .unwrap_or_else(|_| panic!("Failed to parse baseline key: {key_hex}"));

        // Get ID52 from current version
        let current_id52 = secret_key.id52();

        println!("    Expected ID52: {expected_id52}");
        println!("    Current ID52:  {current_id52}");

        // Verify they match
        assert_eq!(
            expected_id52, current_id52,
            "ID52 mismatch! Baseline: {expected_id52}, Current: {current_id52}"
        );

        // Also verify encoding roundtrip (Display should output hex)
        let encoded = secret_key.to_string();
        assert_eq!(
            key_hex, encoded,
            "Encoding changed! Original: {key_hex}, Re-encoded: {encoded}"
        );

        println!("    ✓ Key loads correctly and ID52 matches!");
    }

    println!("\n✓ All baseline keys work with current version!");
}

#[test]
fn test_public_key_from_baseline() {
    // Test that we can derive the same public key from baseline secret
    let baseline_secret_hex = "100d7e23f222267ba0be43855a262461b8a7718572edf58c56db912156d2bc25";
    let expected_id52 = "i66fo538lfl5ombdf6tcdbrabp4hmp9asv7nrffuc2im13ct4q60";

    let secret = fastn_id52::SecretKey::from_str(baseline_secret_hex)
        .expect("Failed to parse baseline secret");

    let public_key = secret.public_key();
    let id52 = public_key.to_string();

    assert_eq!(
        id52, expected_id52,
        "Public key ID52 doesn't match baseline"
    );

    // Test parsing the ID52
    use std::str::FromStr;
    let parsed_public = fastn_id52::PublicKey::from_str(&id52).expect("Failed to parse ID52");
    let id52_roundtrip = parsed_public.to_string();

    assert_eq!(id52, id52_roundtrip, "ID52 roundtrip failed");
}

#[test]
fn test_bytes_representation() {
    // Verify that to_bytes and from_bytes work correctly
    let baseline_secret_hex = "100d7e23f222267ba0be43855a262461b8a7718572edf58c56db912156d2bc25";

    let secret = fastn_id52::SecretKey::from_str(baseline_secret_hex)
        .expect("Failed to parse baseline secret");

    let bytes = secret.to_bytes();
    assert_eq!(bytes.len(), 32, "Secret key should be 32 bytes");

    // Verify the bytes match the hex
    let expected_bytes = hex::decode(baseline_secret_hex).expect("Failed to decode hex");
    assert_eq!(bytes.to_vec(), expected_bytes, "Bytes don't match hex");

    // Test from_bytes
    let secret2 = fastn_id52::SecretKey::from_bytes(&bytes);
    let hex2 = secret2.to_string();
    assert_eq!(baseline_secret_hex, hex2, "from_bytes roundtrip failed");
}

#[test]
fn test_generate_and_parse() {
    // Generate a new key and verify it roundtrips correctly
    let (_id52, secret) = fastn_net::generate_secret_key().expect("Failed to generate secret key");

    let hex = secret.to_string();
    assert_eq!(hex.len(), 64, "Generated key should be 64 hex chars");

    // Parse it back
    let secret2 = fastn_id52::SecretKey::from_str(&hex).expect("Failed to parse generated key");

    let hex2 = secret2.to_string();
    assert_eq!(hex, hex2, "Generated key roundtrip failed");

    // Verify ID52 is consistent
    let id52_1 = secret.id52();
    let id52_2 = secret2.id52();
    assert_eq!(id52_1, id52_2, "ID52 not consistent after roundtrip");
}
