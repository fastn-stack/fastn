//! Test compatibility with keys generated by baseline version
//!
//! These test keys were generated using malai keygen from commit 11d4d3f
//! and stored in test-keys/ directory to ensure backward compatibility.

use std::fs;
use std::str::FromStr;

#[test]
fn test_baseline_keys_load_correctly() {
    // These are the actual keys and ID52s generated by baseline malai keygen
    let test_data = vec![
        (
            "../test-keys/key-1.txt",
            "100d7e23f222267ba0be43855a262461b8a7718572edf58c56db912156d2bc25",
            "i66fo538lfl5ombdf6tcdbrabp4hmp9asv7nrffuc2im13ct4q60",
        ),
        (
            "../test-keys/key-2.txt",
            "e357e8a31fa82958cf0a7697846cb9ed494807d5d8bf95bac9ed21207d8ce6a3",
            "e87aeds2fajaeu10tjdio5ppcdha410n6tu4665u7el9as9b7v80",
        ),
        (
            "../test-keys/key-3.txt",
            "a0ed7d4cdd3a2941a289f6bde83717898cccde35b0a8c2944aba66f87a2dcfa9",
            "mlk9ubnvu8r1sk06j4tjb98njra0od5d2dglpm8gubbvg4glthng",
        ),
    ];

    for (file_path, expected_hex, expected_id52) in test_data {
        println!("Testing {file_path}");

        // Read the key file generated by baseline
        let key_content =
            fs::read_to_string(file_path).unwrap_or_else(|_| panic!("Failed to read {file_path}"));
        let key_hex = key_content.trim();

        // Verify it matches expected hex
        assert_eq!(
            key_hex, expected_hex,
            "Key file content doesn't match expected"
        );

        // Load with current version
        let secret = fastn_id52::SecretKey::from_str(key_hex)
            .unwrap_or_else(|_| panic!("Failed to parse key from {file_path}"));

        // Verify ID52 matches
        let id52 = secret.id52();
        assert_eq!(
            id52, expected_id52,
            "ID52 mismatch for {file_path}! Expected: {expected_id52}, Got: {id52}"
        );

        // Verify hex encoding roundtrips
        let encoded = secret.to_string();
        assert_eq!(
            encoded, expected_hex,
            "Hex encoding changed for {file_path}!"
        );

        println!("  ✓ {file_path} loads correctly, ID52 matches");
    }
}

#[test]
fn test_signature_with_baseline_key() {
    // Load a baseline key
    let key_hex = fs::read_to_string("../test-keys/key-1.txt")
        .expect("Failed to read baseline key")
        .trim()
        .to_string();

    let secret = fastn_id52::SecretKey::from_str(&key_hex).expect("Failed to parse baseline key");

    let public_key = secret.public_key();

    // Create and verify signature
    let message = b"Test message for signature verification";
    let signature = secret.sign(message);

    // Verify signature
    assert!(
        public_key.verify(message, &signature).is_ok(),
        "Signature verification failed"
    );

    // Verify wrong message fails
    assert!(
        public_key.verify(b"Wrong message", &signature).is_err(),
        "Should fail for wrong message"
    );

    println!("✓ Signature verification works with baseline key");
}

#[test]
fn test_public_key_derivation() {
    // Test that public keys are derived consistently
    let key_hex = fs::read_to_string("../test-keys/key-1.txt")
        .expect("Failed to read baseline key")
        .trim()
        .to_string();

    let expected_id52 = "i66fo538lfl5ombdf6tcdbrabp4hmp9asv7nrffuc2im13ct4q60";

    // Load key multiple times
    let secret1 = fastn_id52::SecretKey::from_str(&key_hex).unwrap();
    let secret2 = fastn_id52::SecretKey::from_str(&key_hex).unwrap();

    // Public keys should be identical
    let pub1 = secret1.public_key();
    let pub2 = secret2.public_key();

    assert_eq!(pub1.to_string(), pub2.to_string());
    assert_eq!(pub1.to_string(), expected_id52);

    // Test ID52 roundtrip
    use std::str::FromStr;
    let parsed = fastn_id52::PublicKey::from_str(expected_id52).expect("Failed to parse ID52");
    assert_eq!(parsed.to_string(), expected_id52);

    println!("✓ Public key derivation is consistent");
}

#[test]
fn test_bytes_encoding() {
    let key_hex = fs::read_to_string("../test-keys/key-1.txt")
        .expect("Failed to read baseline key")
        .trim()
        .to_string();

    let secret = fastn_id52::SecretKey::from_str(&key_hex).unwrap();

    // to_bytes and from_bytes
    let bytes = secret.to_bytes();
    assert_eq!(bytes.len(), 32);

    let secret2 = fastn_id52::SecretKey::from_bytes(&bytes);
    assert_eq!(secret2.to_string(), key_hex);
    assert_eq!(secret2.id52(), secret.id52());

    println!("✓ Bytes encoding works correctly");
}
