<!DOCTYPE html>
<html lang="en" style="height: 100%;">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=0">
<title></title>
<script type="ftd" id="ftd-data">
{
"foo#flag": true,
"foo#num": 0
}
</script>
<script type="ftd" id="ftd-external-children">
{}
</script>
<script>

</script>
<style>


</style>

</head>
<body style="height: 100%;">

<div data-id="main" style="align-items: flex-start; display: flex; flex-direction: column; justify-content: flex-start; text-decoration: none" ><div data-id="0:main" style="display: none; padding: 50px; text-decoration: none" class="ft_md">Hello World</div><div data-id="1:main" style="text-decoration: none" class="ft_md">0</div><div data-id="2:main" style="text-decoration: none" class="ft_md">Gee</div><div data-id="3:main" onclick="window.ftd.handle_event(event, 'main', '[{&quot;name&quot;:&quot;foo__increment___main&quot;,&quot;values&quot;:{&quot;a&quot;:{&quot;mutable&quot;:true,&quot;reference&quot;:&quot;foo#num&quot;}}},{&quot;name&quot;:&quot;foo__toggle___main&quot;,&quot;values&quot;:{&quot;a&quot;:{&quot;mutable&quot;:true,&quot;reference&quot;:&quot;foo#flag&quot;}}}]', this)" style="text-decoration: none" class="ft_md">Click here</div></div>


<script>
"use strict";
window.ftd = (function () {
let ftd_data = {};
let exports = {};
exports.init = function (id, data) {
let element = document.getElementById(data);
if (!!element) {
ftd_data[id] = JSON.parse(element.innerText);
// window.ftd.post_init();
}
};
function handle_function(evt, id, action, obj, function_arguments) {
console.log(id, action);
console.log(action.name);
let argument;
for (argument in action.values) {
if (action.values.hasOwnProperty(argument)) {
if (typeof action.values[argument] === 'object') {
let function_argument = action.values[argument];
if (!!function_argument.reference) {
let value = resolve_reference(function_argument.reference, ftd_data[id]);
if (!!function_argument.mutable) {
function_argument.value = value;
function_arguments.push(function_argument);
}
else {
function_arguments.push(deepCopy(value));
}
}
}
else {
function_arguments.push(action.values[argument]);
}
}
}
return window[action.name](...function_arguments);
}
function handle_event(evt, id, action, obj) {
let function_arguments = [];
handle_function(evt, id, action, obj, function_arguments);
change_value(function_arguments, ftd_data[id], id);
if (!!window["node_change_" + id]) {
window["node_change_" + id](ftd_data[id]);
}
}
exports.handle_event = function (evt, id, event, obj) {
console_log(id, event);
let actions = JSON.parse(event);
for (const action in actions) {
handle_event(evt, id, actions[action], obj);
}
};
exports.handle_function = function (evt, id, event, obj) {
console_log(id, event);
let actions = JSON.parse(event);
let function_arguments = [];
return handle_function(evt, id, actions, obj, function_arguments);
};
return exports;
})();
/*
window.ftd.post_init = function () {
const DARK_MODE = "ftd#dark-mode";
const SYSTEM_DARK_MODE = "ftd#system-dark-mode";
const FOLLOW_SYSTEM_DARK_MODE = "ftd#follow-system-dark-mode";
const DARK_MODE_COOKIE = "ftd-dark-mode";
const COOKIE_SYSTEM_LIGHT = "system-light";
const COOKIE_SYSTEM_DARK = "system-dark";
const COOKIE_DARK_MODE = "dark";
const COOKIE_LIGHT_MODE = "light";
const DARK_MODE_CLASS = "fpm-dark";
const MOBILE_CLASS = "ftd-mobile";
const XL_CLASS = "ftd-xl";
const FTD_DEVICE = "ftd#device";
const FTD_MOBILE_BREAKPOINT = "ftd#mobile-breakpoint";
const FTD_DESKTOP_BREAKPOINT = "ftd#desktop-breakpoint";
const FTD_THEME_COLOR = "ftd#theme-color";
const THEME_COLOR_META = "theme-color";
const MARKDOWN_COLOR = "ftd#markdown-color";
const MARKDOWN_BACKGROUND_COLOR = "ftd#markdown-background-color";
let last_device: string;

function initialise_device() {
last_device = get_device();
console_log("last_device", last_device);
window.ftd.set_bool_for_all(FTD_DEVICE, last_device);
}

window.onresize = function () {
let current = get_device();
if (current === last_device) {
return;
}

window.ftd.set_string_for_all(FTD_DEVICE, current);
last_device = current;
console_log("last_device", last_device);
};

function update_markdown_colors() {
// remove all colors from ftd.css: copy every deleted stuff in this function
let markdown_style_sheet = document.createElement('style');


markdown_style_sheet.innerHTML = `
.ft_md a {
color: ${window.ftd.get_value("main", MARKDOWN_COLOR + ".link.light")};
background-color: ${window.ftd.get_value("main", MARKDOWN_BACKGROUND_COLOR + ".link.light")};
}
body.fpm-dark .ft_md a {
color: ${window.ftd.get_value("main", MARKDOWN_COLOR + ".link.dark")};
background-color: ${window.ftd.get_value("main", MARKDOWN_BACKGROUND_COLOR + ".link.dark")};
}

.ft_md code {
color: ${window.ftd.get_value("main", MARKDOWN_COLOR + ".code.light")};
background-color: ${window.ftd.get_value("main", MARKDOWN_BACKGROUND_COLOR + ".code.light")};
}
body.fpm-dark .ft_md code {
color: ${window.ftd.get_value("main", MARKDOWN_COLOR + ".code.dark")};
background-color: ${window.ftd.get_value("main", MARKDOWN_BACKGROUND_COLOR + ".code.dark")};
}

.ft_md a:visited {
color: ${window.ftd.get_value("main", MARKDOWN_COLOR + ".link-visited.light")};
background-color: ${window.ftd.get_value("main", MARKDOWN_BACKGROUND_COLOR + ".link-visited.light")};
}
body.fpm-dark .ft_md a:visited {
color: ${window.ftd.get_value("main", MARKDOWN_COLOR + ".link-visited.dark")};
background-color: ${window.ftd.get_value("main", MARKDOWN_BACKGROUND_COLOR + ".link-visited.dark")};
}

.ft_md a code {
color: ${window.ftd.get_value("main", MARKDOWN_COLOR + ".link-code.light")};
background-color: ${window.ftd.get_value("main", MARKDOWN_BACKGROUND_COLOR + ".link-code.light")};
}
body.fpm-dark .ft_md a code {
color: ${window.ftd.get_value("main", MARKDOWN_COLOR + ".link-code.dark")};
background-color: ${window.ftd.get_value("main", MARKDOWN_BACKGROUND_COLOR + ".link-code.dark")};
}

.ft_md a:visited code {
color: ${window.ftd.get_value("main", MARKDOWN_COLOR + ".link-visited-code.light")};
background-color: ${window.ftd.get_value("main", MARKDOWN_BACKGROUND_COLOR + ".link-visited-code.light")};
}
body.fpm-dark .ft_md a:visited code {
color: ${window.ftd.get_value("main", MARKDOWN_COLOR + ".link-visited-code.dark")};
background-color: ${window.ftd.get_value("main", MARKDOWN_BACKGROUND_COLOR + ".link-visited-code.dark")};
}

.ft_md ul ol li:before {
color: ${window.ftd.get_value("main", MARKDOWN_COLOR + ".ul-ol-li-before.light")};
background-color: ${window.ftd.get_value("main", MARKDOWN_BACKGROUND_COLOR + ".ul-ol-li-before.light")};
}
body.fpm-dark .ft_md ul ol li:before {
color: ${window.ftd.get_value("main", MARKDOWN_COLOR + ".ul-ol-li-before.dark")};
background-color: ${window.ftd.get_value("main", MARKDOWN_BACKGROUND_COLOR + ".ul-ol-li-before.dark")};
}
`;

document.getElementsByTagName('head')[0].appendChild(markdown_style_sheet);
}

function get_device() {
// not at all sure about this functions logic.
let width = window.innerWidth;

// in future we may want to have more than one break points, and then
// we may also want the theme builders to decide where the breakpoints
// should go. we should be able to fetch fpm variables here, or maybe
// simply pass the width, user agent etc to fpm and let people put the
// checks on width user agent etc, but it would be good if we can
// standardize few breakpoints. or maybe we should do both, some
// standard breakpoints and pass the raw data.

// we would then rename this function to detect_device() which will
// return one of "desktop", "tablet", "mobile". and also maybe have
// another function detect_orientation(), "landscape" and "portrait" etc,
// and instead of setting `fpm#mobile: boolean` we set `fpm-ui#device`
// and `fpm#view-port-orientation` etc.
let mobile_breakpoint = window.ftd.get_value("main", FTD_MOBILE_BREAKPOINT);
let desktop_breakpoint = window.ftd.get_value("main", FTD_DESKTOP_BREAKPOINT);
if (width <= mobile_breakpoint) {
document.body.classList.add(MOBILE_CLASS);
if (document.body.classList.contains(XL_CLASS)) {
document.body.classList.remove(XL_CLASS);
}
return "mobile";
}
if (width > desktop_breakpoint) {
document.body.classList.add(XL_CLASS);
if (document.body.classList.contains(MOBILE_CLASS)) {
document.body.classList.remove(MOBILE_CLASS);
}
return "xl";
}
if (document.body.classList.contains(MOBILE_CLASS)) {
document.body.classList.remove(MOBILE_CLASS);
}
if (document.body.classList.contains(XL_CLASS)) {
document.body.classList.remove(XL_CLASS);
}
return "desktop";
}

/!*
ftd.dark-mode behaviour:

ftd.dark-mode is a boolean, default false, it tells the UI to show
the UI in dark or light mode. Themes should use this variable to decide
which mode to show in UI.

ftd.follow-system-dark-mode, boolean, default true, keeps track if
we are reading the value of `dark-mode` from system preference, or user
has overridden the system preference.

These two variables must not be set by ftd code directly, but they must
use `$on-click$: message-host enable-dark-mode`, to ignore system
preference and use dark mode. `$on-click$: message-host
disable-dark-mode` to ignore system preference and use light mode and
`$on-click$: message-host follow-system-dark-mode` to ignore user
preference and start following system preference.

we use a cookie: `ftd-dark-mode` to store the preference. The cookie can
have three values:

cookie missing /          user wants us to honour system preference
system-light          and currently its light.

system-dark               follow system and currently its dark.

light:                    user prefers light

dark:                     user prefers light

We use cookie instead of localstorage so in future `fpm-repo` can see
users preferences up front and renders the HTML on service wide
following user's preference.

*!/

window.enable_dark_mode = function () {
// TODO: coalesce the two set_bool-s into one so there is only one DOM
//       update
window.ftd.set_bool_for_all(DARK_MODE, true);
window.ftd.set_bool_for_all(FOLLOW_SYSTEM_DARK_MODE, false);
window.ftd.set_bool_for_all(SYSTEM_DARK_MODE, system_dark_mode());
document.body.classList.add(DARK_MODE_CLASS);
set_cookie(DARK_MODE_COOKIE, COOKIE_DARK_MODE);
update_theme_color();
};

window.enable_light_mode = function () {
// TODO: coalesce the two set_bool-s into one so there is only one DOM
//       update
window.ftd.set_bool_for_all(DARK_MODE, false);
window.ftd.set_bool_for_all(FOLLOW_SYSTEM_DARK_MODE, false);
window.ftd.set_bool_for_all(SYSTEM_DARK_MODE, system_dark_mode());
if (document.body.classList.contains(DARK_MODE_CLASS)) {
document.body.classList.remove(DARK_MODE_CLASS);
}
set_cookie(DARK_MODE_COOKIE, COOKIE_LIGHT_MODE);
update_theme_color();
};

window.enable_system_mode = function () {
// TODO: coalesce the two set_bool-s into one so there is only one DOM
//       update
window.ftd.set_bool_for_all(FOLLOW_SYSTEM_DARK_MODE, true);
window.ftd.set_bool_for_all(SYSTEM_DARK_MODE, system_dark_mode());
if (system_dark_mode()) {
window.ftd.set_bool_for_all(DARK_MODE, true);
document.body.classList.add(DARK_MODE_CLASS);
set_cookie(DARK_MODE_COOKIE, COOKIE_SYSTEM_DARK);
} else {
window.ftd.set_bool_for_all(DARK_MODE, false);
if (document.body.classList.contains(DARK_MODE_CLASS)) {
document.body.classList.remove(DARK_MODE_CLASS);
}
set_cookie(DARK_MODE_COOKIE, COOKIE_SYSTEM_LIGHT);
}
update_theme_color();
};

function update_theme_color() {
let theme_color = window.ftd.get_value("main", FTD_THEME_COLOR);
if (!!theme_color) {
document.body.style.backgroundColor = FTD_THEME_COLOR;
set_meta(THEME_COLOR_META, theme_color);
} else {
document.body.style.backgroundColor = FTD_THEME_COLOR;
delete_meta(THEME_COLOR_META);
}
}

function set_meta(name: string, value: string) {
let meta: HTMLMetaElement | null = document.querySelector("meta[name=" + name + "]");
if (!!meta) {
meta.content = value;
} else {
meta = document.createElement('meta');
meta.name = name;
meta.content = value;
document.getElementsByTagName('head')[0].appendChild(meta);
}
}

function delete_meta(name: string) {
let meta = document.querySelector("meta[name=" + name + "]");
if (!!meta) {
meta.remove();
}
}

function set_cookie(name: string, value: string) {
document.cookie = name + "=" + value + "; path=/";
}

function system_dark_mode() {
return !!(window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches);
}

function initialise_dark_mode() {
update_dark_mode();
start_watching_dark_mode_system_preference();
}

function get_cookie(name: string, def: string) {
// source: https://stackoverflow.com/questions/5639346/
let regex = document.cookie.match('(^|;)\\s*' + name + '\\s*=\\s*([^;]+)');
return regex !== null ? regex.pop() : def;
}

function update_dark_mode() {
let current_dark_mode_cookie = get_cookie(DARK_MODE_COOKIE, COOKIE_SYSTEM_LIGHT);

switch (current_dark_mode_cookie) {
case COOKIE_SYSTEM_LIGHT:
case COOKIE_SYSTEM_DARK:
window.enable_system_mode();
break;
case COOKIE_LIGHT_MODE:
window.enable_light_mode();
break;
case COOKIE_DARK_MODE:
window.enable_dark_mode();
break;
default:
console_log("cookie value is wrong", current_dark_mode_cookie);
window.enable_system_mode();
}
}

function start_watching_dark_mode_system_preference() {
window.matchMedia('(prefers-color-scheme: dark)').addEventListener(
"change", update_dark_mode
);
}
initialise_dark_mode();
initialise_device();
update_markdown_colors();
};*/
function console_log(...message) {
if (true) { // false
console.log(...message);
}
}
function isObject(obj) {
return obj != null && typeof obj === 'object' && obj === Object(obj);
}
function resolve_reference(reference, data) {
return data[reference];
}
function deepCopy(object) {
if (isObject(object)) {
return JSON.parse(JSON.stringify(object));
}
return object;
}
function change_value(function_arguments, data, id) {
for (const a in function_arguments) {
if (isFunctionArgument(function_arguments[a])) {
if (!!function_arguments[a]["reference"]) {
let reference = function_arguments[a]["reference"];
if (!!window["set_value_" + id] && !!window["set_value_" + id][reference]) {
window["set_value_" + id][reference](data, function_arguments[a]["value"]);
}
else {
data[reference] = function_arguments[a]["value"];
}
}
}
}
}
function isFunctionArgument(object) {
return object.value !== undefined;
}
String.prototype.format = function () {
var formatted = this;
for (var i = 0; i < arguments.length; i++) {
var regexp = new RegExp('\\{' + i + '\\}', 'gi');
formatted = formatted.replace(regexp, arguments[i]);
}
return formatted;
};

function isempty(str) {
return (!str || str.length === 0 );
}


function foo__increment___main(a){
return (a.value += 1);
}



function foo__toggle___main(a){
a.value = !a.value;
}


function node_change_main(data){
if(function(){
return ((data["foo#num"]>2)&&data["foo#flag"]);
}()){
document.querySelector(`[data-id="0:main"]`).style["display"] = "flex";
}
else {document.querySelector(`[data-id="0:main"]`).style["display"] = "none";}
if(function(){
return data["foo#flag"];
}()){
document.querySelector(`[data-id="0:main"]`).style["padding"] = "{0}px".format(50);
}
document.querySelector(`[data-id="1:main"]`).innerHTML = data["foo#num"];
if(function(){
return data["foo#flag"];
}()){
document.querySelector(`[data-id="2:main"]`).style["display"] = "flex";
}
else {document.querySelector(`[data-id="2:main"]`).style["display"] = "none";}
}



window.ftd.init("main", "ftd-data", "ftd-external-children");
</script>
</body>
</html>
